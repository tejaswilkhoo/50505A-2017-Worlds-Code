#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    potentiometerbar, sensorPotentiometer)
#pragma config(Sensor, in8,    potentiometerlift, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  ,               sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           leftdrive,     tmotorVex393HighSpeed_HBridge, openLoop, reversed, driveLeft)
#pragma config(Motor,  port2,           leftdrive,     tmotorVex393HighSpeed_MC29, openLoop, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port4,           chainbar,      tmotorVex393_MC29, openLoop, encoderPort, None)
#pragma config(Motor,  port5,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           conelift,      tmotorVex393_MC29, openLoop, encoderPort, None)
#pragma config(Motor,  port8,           mobilelift,    tmotorVex393_MC29, PIDControl, encoderPort, dgtl1)
#pragma config(Motor,  port9,           rightdrive,    tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight, encoderPort, I2C_2)
#pragma config(Motor,  port10,          rightdrive,    tmotorVex393HighSpeed_HBridge, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(0)
#pragma userControlDuration(60)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!


task MobilePickup()
{
	setMotorTarget(port8,0,127,true);
	waitUntilMotorStop(port8);
}

task MobilePutDown()
{
	setMotorTarget(port8,-95,-127,true);
	waitUntilMotorStop(port8);
}

void pre_auton()
{
	resetMotorEncoder(port8);
	bStopTasksBetweenModes = true;
}

task autonomous()
{}




task usercontrol()
{

	while (true)
	{

		motor[port1] = abs(vexRT[Ch3]) > 10 ? vexRT[Ch3] : 0;
		motor[port2] = abs(vexRT[Ch3]) > 10 ? vexRT[Ch3] : 0;
		motor[port9] = abs(vexRT[Ch2]) > 10 ? vexRT[Ch2] : 0;
		motor[port10] = abs(vexRT[Ch2]) > 10 ? vexRT[Ch2] : 0;

		if (vexRT[Btn6U]==1)
		{
			motor[port7] = 127;
		}
		else if (vexRT[Btn6D]==1)
		{
			motor[port7]=-127;
		}
		else
		{
			motor[port7]=0;
		}

		if (vexRT[Btn5U]==1)
		{
			motor[port5]=127;
		}

		else if (vexRT[Btn5D]==1)
		{
			motor[port5]=-127;
		}
		else
		{
			motor[port5]=0;
		}


		if (vexRT[Btn7U]==1)
		{
			motor[port4] = 127;

		}
		else if (vexRT[Btn7D]==1)
		{
			motor[port4]=-127;

		}
		else
		{
			if (SensorValue(potentiometerbar) < 300)
			{
				motor[port4]=0;
			}

			if (SensorValue(potentiometerbar) > 300 && SensorValue(potentiometerbar) < 1000)
			{
				motor[port4]=-20;
			}

			if (SensorValue(potentiometerbar) > 1000 && SensorValue(potentiometerbar) < 1200)
			{
				motor[port4]=0;
			}

			if (SensorValue(potentiometerbar) > 1200 && SensorValue(potentiometerbar) < 3800)
			{
				motor[port4]=20;
			}

			if (SensorValue(potentiometerbar) > 3800)
			{
				motor[port4]=0;
			}
		}

		if (vexRT[Btn8D]==1)
		{
			startTask(MobilePutDown);
		}
		if (vexRT[Btn8U]==1)
		{
			startTask(MobilePickup);
		}
	}
}
